# Вариант 1
## Часть 1: Design Patterns
    Расписать что из себя представляет Singleton Design Pattern. Нарисовать «псевдо» UML диаграмму. Расписать какие аспекты инкапсулирует DP, какие аспекты изменчивости и сложности, привести примеры
    
**Singleton** - это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
Применяется, когда в программе должен быть единственный экземпляр класса, который доступен всем клиентам

Шаблон проектирования Singleton инкапсулирует следующие аспекты:

- Гарантирует, что в однопоточном приложении будет единственный экземпляр некоторого класса.
- Предоставляет глобальную точку доступа к этому экземпляру.

Этот шаблон проектирования является порождающим и позволяет создать объект, который будет существовать в единственном экземпляре на протяжении всего жизненного цикла приложения. Это достигается путем использования приватного конструктора и публичного статического метода, который проверяет, существует ли объект Singleton, и возвращает его, если он уже создан.

Одним из примеров использования Singleton является класс ```java.lang.Runtime```, который предоставляет интерфейс для взаимодействия с текущей средой выполнения Java. Этот класс является _Singleton_, поскольку в одном приложении может существовать только один экземпляр этого класса.

Шаблон _Singleton_ также имеет свои минусы. Он усложняет тестирование, многопоточность и отслеживание задержек. Одиночки не должны неявно зависеть друг от друга.

Несмотря на это, _Singleton_ является полезным шаблоном проектирования, который может быть использован в различных ситуациях, когда требуется глобальный доступ к единственному экземпляру класса.

_UML-диаграмма:_
![image](https://i.postimg.cc/0v4dmFMc/image.png)
## Часть 2: ООП
    Что такое ООП декомпозиция? Приведите примеры
ООП декомпозиция - это процесс разбиения сложной задачи на более мелкие и управляемые части, которые могут быть легко реализованы. Это позволяет разработчикам лучше понимать систему и упрощать ее сопровождение. 

Примеры ООП декомпозиции:
- **Наследование**: это процесс создания нового класса на основе существующего класса. Новый класс наследует свойства и методы существующего класса и может добавлять свои собственные свойства и методы. Например, класс _Собака_ может наследовать свойства и методы класса _Животное_.
- **Композиция**: это процесс создания нового объекта, используя другие объекты в качестве его частей. Например, класс _Автомобиль_ может состоять из объектов _Двигатель_, _Колеса_ и _Кузов_.
- **Агрегация**: это процесс создания нового объекта, который содержит другие объекты в качестве своих частей, но не является их владельцем. Например, класс _Библиотека_ может содержать объекты _Книга_, но не является их владельцем.
- **Интерфейсы**: это контракты, которые определяют, какие методы должны быть реализованы в классе. Например, интерфейс _Фигура_ может определять методы _Площадь_ и _Периметр_, которые должны быть реализованы в классах _Круг_ и _Прямоугольник_


    Что такое агрегация? Когда нужно применять наследование, а когда агрегацию?
**Агрегация** - это процесс создания нового объекта, который содержит другие объекты в качестве своих частей, но не является их владельцем. Например, класс _Библиотека_ может содержать объекты _Книга_, но не является их владельцем.

_Наследование_ и _агрегация_ - это два разных подхода к проектированию классов. Наследование используется, когда один класс наследует свойства и методы другого класса. Это позволяет избежать дублирования кода и повторного использования существующего кода.
_Агрегация_ используется, когда один объект содержит другой объект в качестве своей части. Это позволяет создавать более сложные объекты из более простых.
Когда нужно использовать наследование, а когда агрегацию, зависит от конкретной задачи и требований к системе. В общем случае, наследование используется, когда классы имеют общие свойства и методы, а агрегация - когда объекты состоят из более простых объектов.
    
    Что такое Абстрагирование? Почему Гради Буч ввел Абстрагирование как 4-й принцип ООП?
    
**Абстрагирование** - это процесс выделения важных характеристик объекта и игнорирования неважных. В контексте ООП, абстрагирование позволяет разработчикам сконцентрироваться на важных аспектах объекта и скрыть детали реализации. Например, класс _Автомобиль_ может иметь свойства, такие как _Марка_, _Модель_ и _Год выпуска_, но скрывать детали реализации, такие как _Количество цилиндров_ и _Объем двигателя_.

Гради Буч ввел абстрагирование как 4-й принцип ООП, потому что это позволяет разработчикам создавать более гибкие и удобные системы. Абстрагирование позволяет скрыть детали реализации и сосредоточиться на важных аспектах объекта. Это упрощает сопровождение кода и позволяет разработчикам легко изменять систему, не затрагивая ее внутреннюю реализацию.

    Что такое функциональное программирование? Приведите примеры использования функционального программировании
**Функциональное программирование** - это парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании. В функциональном программировании вычисления основаны на вычислении значений функций, а не на изменении состояния программы. Это позволяет средам выполнения программ на функциональных языках кешировать результаты функций и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо дополнительных действий со стороны программиста. Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы.

К преимуществам относятся легкая отладка, модульность, более лучшая читаемость, а также параллельное программирование(программы легче создавать при помощи функционального подхода, потому что неизменяемые переменные снижают число изменений внутри этих программ).

Функциональное программирование может использоваться для:
- создания высоконадежных систем
- для обработки данных
- для разработки алгоритмов
- для разработки параллельных программ
## Часть 3: Элементы промышленного программирования
    «Магическое число» 7 +-2. Связь с «магическим числом» и цикломатической сложностью
**Цикломатическая сложность** - это мера количества линейно независимых путей в коде программы. Она может помочь программистам оценить сложность своего кода и выявить возможные ошибки. Например, если цикломатическая сложность кода превышает 7, это может указывать на то, что код слишком сложный и может содержать ошибки. 

Также, «магическое число» 7 +-2 - это закономерность, обнаруженная американским учёным-психологом Джорджем Миллером. Она заключается в том, что кратковременная человеческая память, как правило, не может запомнить и повторить более 7 ± 2 элементов. Эта закономерность была изложена в его работе «Магическое число семь, плюс-минус два»

Таким образом, связь между «магическим числом» и цикломатической сложностью заключается в том, что она может помочь программистам оценить сложность своего кода и выявить возможные ошибки. Если цикломатическая сложность кода превышает 7, это может указывать на то, что код слишком сложный и может содержать ошибки

    Что такое Test Runner, дайте определение, приведите примеры Java Frameworks.
**Test Runner** - это инструмент, который позволяет запускать тесты в автоматическом режиме и анализировать результаты. Он может использоваться для запуска тестовых сценариев, написанных на различных языках программирования, включая Java.

Некоторые из популярных Java-фреймворков для тестирования, которые используют Test Runner, включают в себя:

1. **JUnit**: Это один из самых популярных фреймворков для тестирования Java-приложений. Он предоставляет множество методов для тестирования различных аспектов приложения, таких как методы, классы и исключения. JUnit также поддерживает аннотации, которые позволяют определять, какие методы являются тестами

2. **Selenium**: Это фреймворк для автоматизации тестирования веб-приложений. Он позволяет создавать тестовые сценарии, которые могут выполняться в различных браузерах и на различных операционных системах. Selenium также поддерживает языки программирования, включая Java

3. **Mockito**: Это фреймворк для создания макетов объектов в Java-приложениях. Он позволяет создавать макеты объектов, которые могут использоваться в тестовых сценариях для имитации реальных объектов

Test Runner является важным инструментом для автоматизации тестирования приложений. Он позволяет быстро запускать тесты и анализировать результаты, что помогает ускорить процесс разработки и повысить качество приложения

    Что такое Reflection в Java? Как используется в контексте Mock frameworks?
**Reflection** в Java - это механизм, который позволяет программе получать информацию о классах, методах, полях и конструкторах во время выполнения. В контексте Mock frameworks, Reflection используется для создания фиктивных объектов, которые могут имитировать поведение реальных объектов

Например, в Mockito, Reflection используется для создания фиктивных объектов, которые могут имитировать поведение реальных объектов. Это позволяет тестировать код, который зависит от других классов, без необходимости создавать реальные экземпляры этих классов. 

Пример использования Reflection в Mockito для создания фиктивного объекта:

```java
MyClass myObject = mock(MyClass.class);
when(myObject.myMethod()).thenReturn(myValue);
```

В этом примере `MyClass` - это класс, который мы хотим протестировать, а `myObject` - это фиктивный объект, созданный с помощью Reflection
    
    Пирамида тестирования? Определение, физический смысл, примеры

Пирамида тестирования - это группировка тестов по уровню детализации и их назначению. Пирамида тестирования состоит из трех уровней: юнит-тесты, интеграционные тесты и системные тесты. Юнит-тесты проверяют отдельные компоненты программы, интеграционные тесты - взаимодействие между компонентами, а системные тесты - работу всей системы в целом. 

Вот примеры тестов, которые могут быть использованы на каждом уровне пирамиды тестирования:

1. **Юнит-тесты**: тестирование функций, методов, классов и модулей. Они обычно пишутся разработчиками и проверяют, что каждый компонент работает правильно
2. **Интеграционные тесты**: тестирование взаимодействия между компонентами. Они проверяют, что компоненты работают правильно вместе
3. **Системные тесты**: тестирование всей системы в целом. Они проверяют, что система работает правильно в реальных условиях
    
## Часть 4: Задачи на кодирование
    Реализовать в ООП стиле следующую задачу: рассчитать первых n факториалов, вернуть контейнер с первыми n факториалами. Код должен быть промышленного качества: обрабатывать ошибки, исключительные ситуации, покрыт UnitTest-ами

[Ссылка на проект](https://github.com/animousen4/FactProj)
## Часть 5: Mock Framework
    Mockito
**Mockito** - это фреймворк для создания заглушек (mock-объектов) в Java. Она позволяет создавать заглушки для классов и интерфейсов, которые используются в тестируемом коде. Mockito может использоваться для тестирования кода, который зависит от других классов или интерфейсов, которые еще не реализованы или не готовы к использованию, а также для изоляции от этих же зависимостей. Ведь в зависимостях тоже есть какой то функционал, а он может отрабатывать некорретно по тем или иным причинам, но в одном тесте мы тестируем один определенный функционал, а не какие то другие зависимые, для них мы пишем отдельные Unit-тесты

Примеры, когда Mockito может быть полезен:

- Мы тестируем код, который зависит от других классов или интерфейсов, но эти классы или интерфейсы еще не реализованы или не готовы к использованию.
- Мы тестируем код, который зависит от внешних сервисов, которые могут быть недоступны во время тестирования.
- Мы тестируем код, который должен обрабатывать исключения, но мы не можем создать ситуацию, которая вызовет исключение.
